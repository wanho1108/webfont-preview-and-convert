<!DOCTYPE html>
<html lang="ko">
<head>
  <%- include('./includes/head'); -%>
</head>
<body>
  <div class="wrapper">
    <%- include('./includes/header'); -%>
    <main id="content" class="content">
      <h2 class="is-blind">본문</h2>
      <section class="typefaces">
        <h3 class="typefaces__heading heading">Typefaces</h3>
        <!-- <div class="typefaces__option">
          <button type="button" aria-selected="true" class="typefaces__option-button">NotoSansCJKkr-Thin</button>
          <button type="button" aria-selected="false" class="typefaces__option-button">NotoSansCJKkr-Light</button>
          <button type="button" aria-selected="false" class="typefaces__option-button">NotoSansCJKkr-Regular</button>
          <button type="button" aria-selected="false" class="typefaces__option-button">NotoSansCJKkr-Medium</button>
          <button type="button" aria-selected="false" class="typefaces__option-button">NotoSansCJKkr-Bold</button>
          <button type="button" aria-selected="false" class="typefaces__option-button">NotoSansCJKkr-Black</button>
        </div> -->
        <h4 class="typeface__heading-2 heading-2">Characters</h4>
        <div>자주 쓰이는 글자를 셀렉트나 버튼으로 !! 제공 난 탭 버튼으로 하고 싶다.</div>
        <div aria-hidden="true" class="typefaces__characters" style="font-family: 'Noto Sans KR', sans-serif;"></div>
        <textarea class="typefaces__original-characters">!@#$%^&*()qwertyuiopasdfghjkl;'zxcvmn,./</textarea>
        <button type="button" class="typefaces__button button">Download fonts</button>
        <h4 class="typeface__heading-2 heading-2">Preview</h4>
        <div>
          <!-- 폰트 사이즈: --, line-height: --, letter-spacing: --, 정렬 좌측, 중간, 우측 -->
          폰트 사이즈: <input type="range" value="0" min="0" max="100">
          line-height: <input type="range" value="0" min="0" max="100">
          letter-spacing: <input type="range" value="0" min="0" max="100">
          <button type="button">정렬 좌측</button>
          <button type="button">정렬 중간</button>
          <button type="button">정렬 우측</button>
        </div>
        <p contenteditable="true" class="typefaces__preview" style="font-family: 'Noto Sans KR', sans-serif;">
          abcdefghijklmnopqrstuvwxyz Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.<br><br>
          abcdefghijklmnopqrstuvwxyz Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popul
          arised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.<br><br>
          근로자는 근로조건의 향상을 위하여 자주적인 단결권·단체교섭권 및 단체행동권을 가진다. 대한민국의 국민이 되는 요건은 법률로 정한다. 국민의 자유와 권리는 헌법에 열거되지 아니한 이유로 경시되지 아니한다. 대법원에 대법관을 둔다. 다만, 법률이 정하는 바에 의하여 대법관이 아닌 법관을 둘 수 있다. 헌법개정안이 제2항의 찬성을 얻은 때에는 헌법개정은 확정되며, 대통령은 즉시 이를 공포하여야 한다. 형사피고인은 유죄의 판결이 확정될 때까지는 무죄로 추정된다. 공무원인 근로자는 법률이 정하는 자에 한하여 단결권·단체교섭권 및 단체행동권을 가진다.<br><br>
          근로자는 근로조건의 향상을 위하여 자주적인 단결권·단체교섭권 및 단체행동권을 가진다. 대한민국의 국민이 되는 요건은 법률로 정한다. 국민의 자유와 권리는 헌법에 열거되지 아니한 이유로 경시되지 아니한다. 대법원에 대법관을 둔다. 다만, 법률이 정하는 바에 의하여 대법관이 아닌 법관을 둘 수 있다. 헌법개정안이 제2항의 찬성을 얻은 때에는 헌법개정은 확정되며, 대통령은 즉시 이를 공포하여야 한다. 형사피고인은 유죄의 판결이 확정될 때까지는 무죄로 추정된다. 공무원인 근로자는 법률이 정하는 자에 한하여 단결권·단체교섭권 및 단체행동권을 가진다.
        </p>
      </section>
    </main>
    <%- include('./includes/cursor'); -%>
  </div>
  <%- include('./includes/script'); -%>
  <script>
    // document.querySelector('.typefaces__characters').addEventListener('focus', (e) => {
    //   const { currentTarget } = e;
    //   const characters = new Set(currentTarget.textContent);

    //   currentTarget.innerHTML = [...characters].reduce((accumulator, character) => {
    //     return accumulator + character;
    //   }, '');
    // });

    // document.querySelector('.typefaces__characters').addEventListener('keypress', (e) => {
    //   e.preventDefault();
    //   const { key, currentTarget } = e;
    //   document.execCommand('insertHTML', false, `<div>${key}</div>`);
    // });

    // setSelectionRange

    // document.querySelector('.typefaces__characters').addEventListener('focusout', (e) => {
    //   const { currentTarget, key } = e;
    //   const characters = new Set(currentTarget.textContent);

    //   currentTarget.innerHTML = [...characters].reduce((accumulator, character) => {
    //     return accumulator + `<span contenteditable="false">${character}</span>`;
    //   }, '');
    // });

    // const rangeIndex = null;

    // <Todo>
    // 리팩토링 필요합니다.

    // class Characters {
    //   constructor(characters) {
    //     this.characters = new Set(characters);
    //   }

    //   has(character) {
    //     return this.characters.has(character);
    //   }

    //   add(character) {
    //     if (this.has(character)) {
    //       return false;
    //     }
    //     this.characters.add(character);
    //     return true;
    //   }

    //   delete(character) {
    //     return this.characters.delete(character);
    //   }

    //   get() {
    //     return this.characters;
    //   }
    // }

    // const characters = new Characters(document.querySelector('.typefaces__original-characters').value);

    // const characters = new Set(document.querySelector('.typefaces__original-characters').value);

    const characters = [...new Set(document.querySelector('.typefaces__original-characters').value)];
    let selectionRange = null;

    console.log(characters);

    document.querySelector('.typefaces__characters').addEventListener('click', (e) => {
      const { target, currentTarget } = e;
      const siblingsElement = currentTarget.children;
      const originTextElement = document.querySelector('.typefaces__original-characters');

      if (target.tagName.toLowerCase() === 'span') {
        // <Todo>
        // 커서의 위치가 엘리먼트 기준 좌측이면 좌측에 엘리먼트 삽입, 우측이면 우측에 엘리먼트 삽입
        const index = Array.prototype.indexOf.call(siblingsElement, target) + 1;
        const newElement = document.createElement('span');

        newElement.classList.add('focus');
        currentTarget.insertBefore(newElement, siblingsElement[index]);
        originTextElement.focus();
        originTextElement.setSelectionRange(index, index);
        selectionRange = index;
      }
    });

    function add(key) {
      const typefacesCharactersElement = document.querySelector('.typefaces__characters');
      const childElement = typefacesCharactersElement.children;
      const newElement = document.createElement('span');

      newElement.textContent = key;
      typefacesCharactersElement.insertBefore(newElement, childElement[selectionRange - 1]);

    }

    document.querySelector('.typefaces__original-characters').addEventListener('keyup', (e) => {
      const { target, key } = e;

      if (key.length !== 1) {
        e.preventDefault();
        console.log('무언가와 함꼐 눌렀군요.');
        return;
      }

      if (characters.indexOf(key) === -1) {
        characters.splice(selectionRange, 0, key);
        selectionRange = target.selectionStart;
        add(key);
        // console.log(target.selectionStart, target.selectionEnd);
        // console.log(target.value.substring(target.selectionStart, target.selectionEnd));
        // add(key);
        // getSelctionRange?
      }
      // const characters = newCharacters();

      // renderCharacters();
      // characters.add(e.key);
      // render();
    });

    // document.querySelector('.typefaces__original-characters').addEventListener('focusout', (e) => {
      // const { target } = e;
      // const { value } = target;

      // target.value = [...new Set(value)].reduce((accumulator, character) => accumulator + character, '');
    // });


    // document.querySelector('.typefaces__original-characters').addEventListener('focusout', (e) => {
    //   const { target } = e;
    //   const characters = new Set(target.value);

    //   target.value = [...characters].reduce((accumulator, character) => {
    //     return accumulator + character;
    //   }, '');
    //   updateTypefacesCharacters();
    // });

    // function updateTypefacesCharacters() {
      // const originTextElement = document.querySelector('.typefaces__original-characters');
      // const typefacesCharactersElement = document.querySelector('.typefaces__characters');
      // const characters = new Set(originTextElement.value);

      // typefacesCharactersElement.innerHTML = [...characters].reduce((accumulator, character) => {
        // return accumulator + `<span>${character}</span>`;
      // }, '');
    // }

    window.addEventListener('DOMContentLoaded', () => {
      const typefacesCharactersElement = document.querySelector('.typefaces__characters');

      typefacesCharactersElement.innerHTML = [...characters].reduce((accumulator, character) => {
        return accumulator + `<span>${character}</span>`;
      }, '');
    });
  </script>
</html>